<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Custom CI/CD pipeline with AWS CodePipeline</title><base href="/"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="manifest" href="/site.webmanifest"/><link rel="icon" type="image/x-icon" href="/favicon.ico"/><meta name="next-head-count" content="6"/><link rel="preload" href="/_next/static/css/913b0b1d.378f9a9c.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/913b0b1d.378f9a9c.chunk.css" data-n-p=""/><link rel="preload" href="/_next/static/css/styles.8c2a1aa6.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/styles.8c2a1aa6.chunk.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-14e394f03625aeaef11f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-147ea3ada7109f6dc0bb.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.37f4a736348214b3ca94.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.36f305bc31231a76b956.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-c5afcbeb5b3799a5d06c.js" as="script"/><link rel="preload" href="/_next/static/chunks/913b0b1d.0a0b70788b6411282e55.js" as="script"/><link rel="preload" href="/_next/static/chunks/822814f6201705712030b680dc4675b57d062497.9ac4317e33ab36aff73f.js" as="script"/><link rel="preload" href="/_next/static/chunks/styles.210d3c80a2b0e2401248.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/articles/%5Bpath%5D-afcf814f1f7321607eca.js" as="script"/></head><body><div id="__next"><div class="container"><div class="row mb-4 mt-4"><div class="col-6 offset-3"><a href="/">Go back</a><h1>Custom CI/CD pipeline with AWS CodePipeline</h1><p class="text-muted">January 6, 2019</p></div></div><div class="row"><div class="col-6 offset-3"><div style="font-size:150%"><p>Amazon Web Services offers a suite of products for handling continuous integration and continuous delivery workflows.
AWS CodeCommit, CodeBuild and CodeDeploy are glued together by CodePipeline, a tool that allows you to define a
pipeline that automatically starts when a change happens in a repository.</p>
<p>Usually, 3 steps are performed.</p>
<ul>
<li>The source step, that is triggered when a new commit is pushed to a particular branch of a specific <strong>CodeCommit</strong>
repository. In this step the new version of the source code is retrieved and passed over to the next step.</li>
<li>The build step, which usually performs static code validation and creates an artifact ready to be deployed. <strong>CodeBuild</strong>
is the tool you can use on AWS to implement such step. The output artifact is passed over to the next step.</li>
<li>The deploy step, which receives the artifacts to deploy and perform deploy operations. AWS offers <strong>CodeDeploy</strong>, a
tool you can use for defining automatic deploying processes and policies. It integrates very well with a limited set
of AWS services, like AWS Lambda and EC2.</li>
</ul>
<p>There are <strong>some limitations</strong> with AWS CodeDeploy. What if the application you have to deploy does not run on AWS
Lambda nor EC2? For instance, you might have a website hosted on an S3 bucket and you want your deploy step to replace
the bucket content with the new version of the website. You can’t do that with CodeDeploy.</p>
<p>For achieving the desired result you can define a separate CodeBuild project that handles the deployment task.
A CodeBuild project is just a <strong>Docker container</strong> which is spawn when the project runs and executes an instruction
file in project.</p>
<p>I have written a CloudFormation template which creates a CodePipeline for the particular cases where the deployment
step falls outside the scope of CodeDeploy, where the user wants to perform some custom deployment operations.</p>
<p>Features</p>
<ul>
<li>Supports two environments named staging and production.</li>
<li>Custom deployment process which actually runs in CodeBuild.</li>
<li>Manual approval before starting the production build.</li>
</ul>
<p>Here is an example of the pipeline the stack will generate:</p>
<img src="/articles/3/aws-code-pipeline.png" class="img-fluid mb-3" alt="AWS Code Pipeline">

<p>The CodeCommit repository must exist prior the CloudFormation stack is created since the repository name is one of the
input parameters.</p>
<p>The other two parameters are the two Docker images you want to use for the build and deploy steps.</p>
<img src="/articles/3/cloud-formation.png" class="img-fluid mb-3" alt="AWS Cloud Formation">

<p>The <strong>IAM role</strong> which is generated for both CodeBuild projects has minimum permissions. If you need to extend it, you
can either manually update the template or create another stack with an extra
<a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html">IAM Policy</a> for the role.</p>
<p>By default the pipeline stack will export the IAM Role ARN and name:</p>
<img src="/articles/3/cloud-formation-stack.png" class="img-fluid mb-3" alt="AWS Cloud Formation">

<p>That&#39;s it. You can find the template and related instructions
<a href="https://github.com/awslabs/aws-cloudformation-templates/tree/master/community/codestar/custom-ci-cd-pipeline">here</a>.
If you have any questions, feel free to drop me a message or add a comment to my
<a href="https://github.com/awslabs/aws-cloudformation-templates/pull/135">pull request</a>.</p>
</div></div></div></div><p class="text-center small mt-5">Copyright © <!-- -->2021<!-- --> Egidio Caprino. All rights reserved.</p></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":3,"title":"Custom CI/CD pipeline with AWS CodePipeline","name":"custom-ci-cd-pipeline-with-aws-codepipeline","date":1546776000,"content":"\u003cp\u003eAmazon Web Services offers a suite of products for handling continuous integration and continuous delivery workflows.\nAWS CodeCommit, CodeBuild and CodeDeploy are glued together by CodePipeline, a tool that allows you to define a\npipeline that automatically starts when a change happens in a repository.\u003c/p\u003e\n\u003cp\u003eUsually, 3 steps are performed.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe source step, that is triggered when a new commit is pushed to a particular branch of a specific \u003cstrong\u003eCodeCommit\u003c/strong\u003e\nrepository. In this step the new version of the source code is retrieved and passed over to the next step.\u003c/li\u003e\n\u003cli\u003eThe build step, which usually performs static code validation and creates an artifact ready to be deployed. \u003cstrong\u003eCodeBuild\u003c/strong\u003e\nis the tool you can use on AWS to implement such step. The output artifact is passed over to the next step.\u003c/li\u003e\n\u003cli\u003eThe deploy step, which receives the artifacts to deploy and perform deploy operations. AWS offers \u003cstrong\u003eCodeDeploy\u003c/strong\u003e, a\ntool you can use for defining automatic deploying processes and policies. It integrates very well with a limited set\nof AWS services, like AWS Lambda and EC2.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere are \u003cstrong\u003esome limitations\u003c/strong\u003e with AWS CodeDeploy. What if the application you have to deploy does not run on AWS\nLambda nor EC2? For instance, you might have a website hosted on an S3 bucket and you want your deploy step to replace\nthe bucket content with the new version of the website. You can’t do that with CodeDeploy.\u003c/p\u003e\n\u003cp\u003eFor achieving the desired result you can define a separate CodeBuild project that handles the deployment task.\nA CodeBuild project is just a \u003cstrong\u003eDocker container\u003c/strong\u003e which is spawn when the project runs and executes an instruction\nfile in project.\u003c/p\u003e\n\u003cp\u003eI have written a CloudFormation template which creates a CodePipeline for the particular cases where the deployment\nstep falls outside the scope of CodeDeploy, where the user wants to perform some custom deployment operations.\u003c/p\u003e\n\u003cp\u003eFeatures\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSupports two environments named staging and production.\u003c/li\u003e\n\u003cli\u003eCustom deployment process which actually runs in CodeBuild.\u003c/li\u003e\n\u003cli\u003eManual approval before starting the production build.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHere is an example of the pipeline the stack will generate:\u003c/p\u003e\n\u003cimg src=\"/articles/3/aws-code-pipeline.png\" class=\"img-fluid mb-3\" alt=\"AWS Code Pipeline\"\u003e\n\n\u003cp\u003eThe CodeCommit repository must exist prior the CloudFormation stack is created since the repository name is one of the\ninput parameters.\u003c/p\u003e\n\u003cp\u003eThe other two parameters are the two Docker images you want to use for the build and deploy steps.\u003c/p\u003e\n\u003cimg src=\"/articles/3/cloud-formation.png\" class=\"img-fluid mb-3\" alt=\"AWS Cloud Formation\"\u003e\n\n\u003cp\u003eThe \u003cstrong\u003eIAM role\u003c/strong\u003e which is generated for both CodeBuild projects has minimum permissions. If you need to extend it, you\ncan either manually update the template or create another stack with an extra\n\u003ca href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html\"\u003eIAM Policy\u003c/a\u003e for the role.\u003c/p\u003e\n\u003cp\u003eBy default the pipeline stack will export the IAM Role ARN and name:\u003c/p\u003e\n\u003cimg src=\"/articles/3/cloud-formation-stack.png\" class=\"img-fluid mb-3\" alt=\"AWS Cloud Formation\"\u003e\n\n\u003cp\u003eThat\u0026#39;s it. You can find the template and related instructions\n\u003ca href=\"https://github.com/awslabs/aws-cloudformation-templates/tree/master/community/codestar/custom-ci-cd-pipeline\"\u003ehere\u003c/a\u003e.\nIf you have any questions, feel free to drop me a message or add a comment to my\n\u003ca href=\"https://github.com/awslabs/aws-cloudformation-templates/pull/135\"\u003epull request\u003c/a\u003e.\u003c/p\u003e\n","formattedDate":"January 6, 2019"},"__N_SSG":true},"page":"/articles/[path]","query":{"path":"3-custom-ci-cd-pipeline-with-aws-codepipeline"},"buildId":"QgASlTqQfWUdIa3dZ0OXq","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-af28de04c604a2479390.js"></script><script src="/_next/static/chunks/main-14e394f03625aeaef11f.js" async=""></script><script src="/_next/static/chunks/webpack-147ea3ada7109f6dc0bb.js" async=""></script><script src="/_next/static/chunks/framework.37f4a736348214b3ca94.js" async=""></script><script src="/_next/static/chunks/commons.36f305bc31231a76b956.js" async=""></script><script src="/_next/static/chunks/pages/_app-c5afcbeb5b3799a5d06c.js" async=""></script><script src="/_next/static/chunks/913b0b1d.0a0b70788b6411282e55.js" async=""></script><script src="/_next/static/chunks/822814f6201705712030b680dc4675b57d062497.9ac4317e33ab36aff73f.js" async=""></script><script src="/_next/static/chunks/styles.210d3c80a2b0e2401248.js" async=""></script><script src="/_next/static/chunks/pages/articles/%5Bpath%5D-afcf814f1f7321607eca.js" async=""></script><script src="/_next/static/QgASlTqQfWUdIa3dZ0OXq/_buildManifest.js" async=""></script><script src="/_next/static/QgASlTqQfWUdIa3dZ0OXq/_ssgManifest.js" async=""></script></body></html>