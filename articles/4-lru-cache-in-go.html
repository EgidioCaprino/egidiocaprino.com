<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>LRU cache in Go</title><base href="/"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="manifest" href="/site.webmanifest"/><link rel="icon" type="image/x-icon" href="/favicon.ico"/><meta name="next-head-count" content="6"/><link rel="preload" href="/_next/static/css/913b0b1d.378f9a9c.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/913b0b1d.378f9a9c.chunk.css" data-n-p=""/><link rel="preload" href="/_next/static/css/styles.8c2a1aa6.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/styles.8c2a1aa6.chunk.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-14e394f03625aeaef11f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-147ea3ada7109f6dc0bb.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.37f4a736348214b3ca94.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.36f305bc31231a76b956.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-c5afcbeb5b3799a5d06c.js" as="script"/><link rel="preload" href="/_next/static/chunks/913b0b1d.0a0b70788b6411282e55.js" as="script"/><link rel="preload" href="/_next/static/chunks/822814f6201705712030b680dc4675b57d062497.9ac4317e33ab36aff73f.js" as="script"/><link rel="preload" href="/_next/static/chunks/styles.210d3c80a2b0e2401248.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/articles/%5Bpath%5D-afcf814f1f7321607eca.js" as="script"/></head><body><div id="__next"><div class="container"><div class="row mb-4 mt-4"><div class="col-6 offset-3"><a href="/">Go back</a><h1>LRU cache in Go</h1><p class="text-muted">July 21, 2019</p></div></div><div class="row"><div class="col-6 offset-3"><div style="font-size:150%"><p>I recently received an interesting coding challenge from <a href="https://www.dailycodingproblem.com/">Daily Coding Problem</a>
asking to implement an LRU cache with constant time complexity for both the <em>get</em> and <em>set</em> operations.</p>
<p>An LRU cache is cache structure with a maximum capacity. When adding a new element, if the maximum capacity is exceeded, the last recently used item will be removed from the cache.</p>
<p>To access elements in constant time we need a map. We also need to keep track of the order in which we set and get elements so we can remove the last recently used element when the maximum capacity is exceeded. Maps are not sorted. For achieving that we need another data structure: a list. So we are going to use:</p>
<ul>
<li>a map for accessing elements in constant time given the key,</li>
<li>a list for keeping track of the order in which elements are accessed.</li>
</ul>
<p>An hash map has constant time for both the <em>get</em> and <em>set</em> operations and that is all we need from it.
What about the list? What kind of operations we need to perform on it?</p>
<ul>
<li>When a new item is added, we need to <strong>add</strong> it to the top of the list.</li>
<li>When an item is updated, we need to <strong>move</strong> it to the top of the list.</li>
<li>When the maximum capacity is exceeded we need to remove the last element from the list.</li>
</ul>
<p>We cannot do that in constant time with an array-based list. Adding or moving an element to the top of the list will
require to shift all the existing element. For achieving that we are going to use a linked list, specifically a doubly
linked list.</p>
<img src="/articles/4/doubly-linked-list.jpeg" class="img-fluid mb-3" alt="Doubly Linked List">

<p>In this particular list we have pointers to both the front and the bottom of the list. Furthermore, <strong>given an element</strong>,
moving it to the front or the bottom of the list has constant time complexity. We need to already have the element,
otherwise we would need to scan the list to find it. For this reason we are going to store list&#39;s elements in the hash
map. So the algorithm is the following.</p>
<p>Setting an item:</p>
<ul>
<li>if the item is new, create a new element at the front of the linked list and store it in the hash map;</li>
<li>if the item already exists, find the linked list value in the hash map, update its value and move it to the front of
the list.</li>
</ul>
<p>Accessing an item:</p>
<ul>
<li>find the linked list item in the hash map, move it to the front of the list and return the value to the caller.</li>
</ul>
<p>You can find my implementation and related unit tests in Go (Golang)
<a href="https://github.com/EgidioCaprino/al-go-rithms/tree/master/lru">here</a>.</p>
</div></div></div></div><p class="text-center small mt-5">Copyright Â© <!-- -->2021<!-- --> Egidio Caprino. All rights reserved.</p></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":4,"title":"LRU cache in Go","name":"lru-cache-in-go","date":1563710400,"content":"\u003cp\u003eI recently received an interesting coding challenge from \u003ca href=\"https://www.dailycodingproblem.com/\"\u003eDaily Coding Problem\u003c/a\u003e\nasking to implement an LRU cache with constant time complexity for both the \u003cem\u003eget\u003c/em\u003e and \u003cem\u003eset\u003c/em\u003e operations.\u003c/p\u003e\n\u003cp\u003eAn LRU cache is cache structure with a maximum capacity. When adding a new element, if the maximum capacity is exceeded, the last recently used item will be removed from the cache.\u003c/p\u003e\n\u003cp\u003eTo access elements in constant time we need a map. We also need to keep track of the order in which we set and get elements so we can remove the last recently used element when the maximum capacity is exceeded. Maps are not sorted. For achieving that we need another data structure: a list. So we are going to use:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ea map for accessing elements in constant time given the key,\u003c/li\u003e\n\u003cli\u003ea list for keeping track of the order in which elements are accessed.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAn hash map has constant time for both the \u003cem\u003eget\u003c/em\u003e and \u003cem\u003eset\u003c/em\u003e operations and that is all we need from it.\nWhat about the list? What kind of operations we need to perform on it?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWhen a new item is added, we need to \u003cstrong\u003eadd\u003c/strong\u003e it to the top of the list.\u003c/li\u003e\n\u003cli\u003eWhen an item is updated, we need to \u003cstrong\u003emove\u003c/strong\u003e it to the top of the list.\u003c/li\u003e\n\u003cli\u003eWhen the maximum capacity is exceeded we need to remove the last element from the list.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe cannot do that in constant time with an array-based list. Adding or moving an element to the top of the list will\nrequire to shift all the existing element. For achieving that we are going to use a linked list, specifically a doubly\nlinked list.\u003c/p\u003e\n\u003cimg src=\"/articles/4/doubly-linked-list.jpeg\" class=\"img-fluid mb-3\" alt=\"Doubly Linked List\"\u003e\n\n\u003cp\u003eIn this particular list we have pointers to both the front and the bottom of the list. Furthermore, \u003cstrong\u003egiven an element\u003c/strong\u003e,\nmoving it to the front or the bottom of the list has constant time complexity. We need to already have the element,\notherwise we would need to scan the list to find it. For this reason we are going to store list\u0026#39;s elements in the hash\nmap. So the algorithm is the following.\u003c/p\u003e\n\u003cp\u003eSetting an item:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eif the item is new, create a new element at the front of the linked list and store it in the hash map;\u003c/li\u003e\n\u003cli\u003eif the item already exists, find the linked list value in the hash map, update its value and move it to the front of\nthe list.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAccessing an item:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003efind the linked list item in the hash map, move it to the front of the list and return the value to the caller.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou can find my implementation and related unit tests in Go (Golang)\n\u003ca href=\"https://github.com/EgidioCaprino/al-go-rithms/tree/master/lru\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n","formattedDate":"July 21, 2019"},"__N_SSG":true},"page":"/articles/[path]","query":{"path":"4-lru-cache-in-go"},"buildId":"QgASlTqQfWUdIa3dZ0OXq","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-af28de04c604a2479390.js"></script><script src="/_next/static/chunks/main-14e394f03625aeaef11f.js" async=""></script><script src="/_next/static/chunks/webpack-147ea3ada7109f6dc0bb.js" async=""></script><script src="/_next/static/chunks/framework.37f4a736348214b3ca94.js" async=""></script><script src="/_next/static/chunks/commons.36f305bc31231a76b956.js" async=""></script><script src="/_next/static/chunks/pages/_app-c5afcbeb5b3799a5d06c.js" async=""></script><script src="/_next/static/chunks/913b0b1d.0a0b70788b6411282e55.js" async=""></script><script src="/_next/static/chunks/822814f6201705712030b680dc4675b57d062497.9ac4317e33ab36aff73f.js" async=""></script><script src="/_next/static/chunks/styles.210d3c80a2b0e2401248.js" async=""></script><script src="/_next/static/chunks/pages/articles/%5Bpath%5D-afcf814f1f7321607eca.js" async=""></script><script src="/_next/static/QgASlTqQfWUdIa3dZ0OXq/_buildManifest.js" async=""></script><script src="/_next/static/QgASlTqQfWUdIa3dZ0OXq/_ssgManifest.js" async=""></script></body></html>