{"pageProps":{"id":4,"title":"LRU cache in Go","name":"lru-cache-in-go","date":1563710400,"content":"<p>I recently received an interesting coding challenge from <a href=\"https://www.dailycodingproblem.com/\">Daily Coding Problem</a>\nasking to implement an LRU cache with constant time complexity for both the <em>get</em> and <em>set</em> operations.</p>\n<p>An LRU cache is cache structure with a maximum capacity. When adding a new element, if the maximum capacity is exceeded, the last recently used item will be removed from the cache.</p>\n<p>To access elements in constant time we need a map. We also need to keep track of the order in which we set and get elements so we can remove the last recently used element when the maximum capacity is exceeded. Maps are not sorted. For achieving that we need another data structure: a list. So we are going to use:</p>\n<ul>\n<li>a map for accessing elements in constant time given the key,</li>\n<li>a list for keeping track of the order in which elements are accessed.</li>\n</ul>\n<p>An hash map has constant time for both the <em>get</em> and <em>set</em> operations and that is all we need from it.\nWhat about the list? What kind of operations we need to perform on it?</p>\n<ul>\n<li>When a new item is added, we need to <strong>add</strong> it to the top of the list.</li>\n<li>When an item is updated, we need to <strong>move</strong> it to the top of the list.</li>\n<li>When the maximum capacity is exceeded we need to remove the last element from the list.</li>\n</ul>\n<p>We cannot do that in constant time with an array-based list. Adding or moving an element to the top of the list will\nrequire to shift all the existing element. For achieving that we are going to use a linked list, specifically a doubly\nlinked list.</p>\n<img src=\"/articles/4/doubly-linked-list.jpeg\" class=\"img-fluid mb-3\" alt=\"Doubly Linked List\">\n\n<p>In this particular list we have pointers to both the front and the bottom of the list. Furthermore, <strong>given an element</strong>,\nmoving it to the front or the bottom of the list has constant time complexity. We need to already have the element,\notherwise we would need to scan the list to find it. For this reason we are going to store list&#39;s elements in the hash\nmap. So the algorithm is the following.</p>\n<p>Setting an item:</p>\n<ul>\n<li>if the item is new, create a new element at the front of the linked list and store it in the hash map;</li>\n<li>if the item already exists, find the linked list value in the hash map, update its value and move it to the front of\nthe list.</li>\n</ul>\n<p>Accessing an item:</p>\n<ul>\n<li>find the linked list item in the hash map, move it to the front of the list and return the value to the caller.</li>\n</ul>\n<p>You can find my implementation and related unit tests in Go (Golang)\n<a href=\"https://github.com/EgidioCaprino/al-go-rithms/tree/master/lru\">here</a>.</p>\n","formattedDate":"July 21, 2019"},"__N_SSG":true}